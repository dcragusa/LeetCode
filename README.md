# LeetCode

My solutions to LeetCode problems.

Each file has a problem statement, my solution, and a couple of tests, occasionally with my reasoning on how the 
solution was achieved.

<details>
<summary><b>1-9</b></summary>

[1.](1-99/1-9/1.py)
**Two Sum** - 
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

[2.](1-99/1-9/2.py)
**Add Two Numbers** - 
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse 
order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

[3.](1-99/1-9/3.py)
**Longest Substring Without Repeating Characters** - 
Given a string, find the length of the longest substring without repeating characters.

[4.](1-99/1-9/4.py)
**Median of Two Sorted Arrays** - 
There are two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively.
Find the median of the two sorted arrays.

[5.](1-99/1-9/5.py)
**Longest Palindromic Substring** - 
Given a string `s`, find the longest palindromic substring in `s`. 
You may assume that the maximum length of `s` is 1000.

[6.](1-99/1-9/6.py)
**ZigZag Conversion** - 
The string `PAYPALISHIRING` is written in a zigzag pattern on a given number of rows like this:

    P   A   H   N
    A P L S I I G
    Y   I   R

And then read line by line: `PAHNAPLSIIGYIR`

Write the code that will take a string and make this conversion given the number of rows.

[7.](1-99/1-9/7.py)
**Reverse Integer** - 
Given a 32-bit signed integer, reverse digits of an integer.

[8.](1-99/1-9/8.py)
**String to Integer** - 
Implement `atoi` which converts a string to an integer. The function first discards as many whitespace characters as 
necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional 
initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.
The string can contain additional characters after those that form the integral number, which are ignored and have 
no effect on the behavior of this function.

[9.](1-99/1-9/9.py)
**Palindrome Number** - 
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

</details>

<details>
<summary><b>10-19</b></summary>

[10.](1-99/10-19/10.py)
**Regular Expression Matching** -
Given an input string `s` and a pattern `p`, implement regular expression matching with support for `.` and `*`.

[11.](1-99/10-19/11.py)
**Container With Most Water** - 
You are given `n` non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, where each 
represents a point at coordinate <code>(i, a<sub>i</sub>)</code>. `n` vertical lines are drawn such that the two 
endpoints of line `i` are at <code>(i, a<sub>i</sub>)</code> and `(i, 0)`. Find two lines, which together with 
the x-axis form a container, such that the container contains the most water.

[12.](1-99/10-19/12.py)
**Integer to Roman** - 
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from `1` to `3999`.

[13.](1-99/10-19/13.py)
**Roman to Integer** - 
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from `1` to `3999`.

[14.](1-99/10-19/14.py)
**Longest Common Prefix** - 
Write a function to find the longest common prefix string amongst an array of strings.

[15.](1-99/10-19/15.py)
**3Sum** - 
Given an array `nums` of `n` integers, find all unique triplets in the array which give the sum of zero.

[16.](1-99/10-19/16.py)
**3Sum Closest** - 
Given an array `nums` of `n` integers and an integer target, find three integers in nums such that the sum is closest 
to `target`. Return the sum of the three integers. You may assume that each input has exactly one solution.

[17.](1-99/10-19/17.py)
**Letter Combinations of a Phone Number** - 
Given a string containing digits from `2-9` inclusive, return all possible letter combinations (those on telephone
buttons) that the number could represent.

[18.](1-99/10-19/18.py)
**4Sum** - 
Given an array `nums` of `n` integers and an integer `target`, are there elements `a`, `b`, `c`, and `d` in `nums` 
such that `a + b + c + d = target`? Find all unique quadruplets in the array which gives the sum of `target`.

[19.](1-99/10-19/19.py)
**Remove Nth Node From End of List** - 
Given a linked list, remove the `n`<sup>th</sup> node from the end of list and return its head.

</details>

<details>
<summary><b>20-29</b></summary>

[20.](1-99/20-29/20.py)
**Valid Parentheses** -
Given a string containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid.

[21.](1-99/20-29/21.py)
**Merge Two Sorted Lists** - 
Merge two sorted linked lists and return it as a new list. 
The new list should be made by splicing together the nodes of the first two lists.

[22.](1-99/20-29/22.py)
**Generate Parentheses** - 
Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

[23.](1-99/20-29/23.py)
**Merge k Sorted Lists** - 
Merge `k` sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

[24.](1-99/20-29/24.py)
**Swap Nodes in Pairs** - 
Given a linked list, swap every two adjacent nodes and return its head.

[25.](1-99/20-29/25.py)
**Reverse Nodes in k-Group** - 
Given a linked list, reverse the nodes of a linked list `k` at a time and return its modified list.

[26.](1-99/20-29/26.py)
**Remove Duplicates from Sorted Array** - 
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and return the 
new length.

[27.](1-99/20-29/27.py)
**Remove Element** - 
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.

[28.](1-99/20-29/28.py)
**Find Needle in Haystack** - 
Return the index of the first occurrence of a substring `needle` in a string `haystack`, 
or -1 if `needle` is not part of `haystack`.

[29.](1-99/20-29/29.py)
**Divide Two Integers** - 
Given two integers `dividend` and `divisor`, divide two integers without using multiplication, 
division or mod operators. Return the quotient after dividing `dividend` by `divisor`.

</details>

<details>
<summary><b>30-39</b></summary>

[30.](1-99/30-39/30.py)
**Substring with Concatenation of All Words** -
You are given a string `s`, and a list of words `words` that are all of the same length.
Find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and
without any intervening characters.

[31.](1-99/30-39/31.py)
**Next Permutation** - 
Implement `next_permutation`, which rearranges numbers into the lexicographically next greater permutation. If such an 
arrangement is not possible, it must be rearranged as the lowest possible order (i.e. sorted in ascending order). 
The replacement must be in-place and use only constant extra memory.

[32.](1-99/30-39/32.py)
**Longest Valid Parentheses** - 
Given a string containing just the characters `(` and `)`, find the length of the longest valid parentheses substring.

[33.](1-99/30-39/33.py)
**Search in Rotated Sorted Array** - 
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand, e.g. 
`[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]`. You are given a target value to search. 
If found in the array return its index, otherwise return `-1`. You may assume no duplicate exists in the array. 
Your algorithm's runtime complexity must be in the order of `O(log n)`.

[34.](1-99/30-39/34.py)
**Find First and Last Position of Element in Sorted Array** - 
Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given target 
value. Your algorithm's runtime complexity must be in the order of `O(log n)`.

[35.](1-99/30-39/35.py)
**Search Insert Position** - 
Given a sorted array and a target value, return the index if the target is found. If not, 
return the index where it would be if it were inserted in order. You may assume no duplicates in the array.

[36.](1-99/30-39/36.py)
**Valid Sudoku** - 
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated.

[37.](1-99/30-39/37.py)
**Sudoku Solver** - 
Write a program to solve a Sudoku puzzle by filling the empty cells.

[38.](1-99/30-39/38.py)
**Count and Say** - 
The count-and-say sequence is the sequence of integers with the first five terms as following: 
`1, 11, 21, 1211, 111221`. `1` is read off as "one 1" or `11`. `11` is read off as "two 1s" or `21`. 
`21` is read off as "one 2, then one 1" or `1211`. Given an integer `n` where `1 ≤ n ≤ 30`, 
generate the *n*th term of the count-and-say sequence.

[39.](1-99/30-39/39.py)
**Combination Sum** - 
Given a set of candidate numbers `candidates` (without duplicates) and a target number `target`, 
find all unique combinations in `candidates` where the candidate numbers sum to `target`.
The same repeated number may be chosen from `candidates` unlimited number of times.

</details>

<details>
<summary><b>40-49</b></summary>

[40.](1-99/40-49/40.py)
**Combination Sum II** -
Given a collection of candidate numbers `candidates` and a target number `target`,
find all unique combinations in `candidates` where the candidate numbers sum to `target`.
Each number in `candidates` may only be used once in the combination.

[41.](1-99/40-49/41.py)
**First Missing Positive** - 
Given an unsorted integer array, find the smallest missing positive integer. 
Your algorithm should run in `O(n)` time and use constant extra space.

[42.](1-99/40-49/42.py)
**Trapping Rain Water** - 
Given `n` non-negative integers representing an elevation map where the width of each bar is 1, 
compute how much water it is able to trap after raining.

[43.](1-99/40-49/43.py)
**Multiply Strings** - 
Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, 
also represented as a string. You must not convert the inputs to integers directly.

[44.](1-99/40-49/44.py)
**Wildcard Matching** - 
Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `?` and `*`.
`?` Matches any single character, while `*` matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string.

[45.](1-99/40-49/45.py)
**Jump Game II** - 
You are given an array of non-negative integers, and are initially positioned at the first index of the array. 
Each element in the array represents your maximum jump length from that position. 
Return the fewest number of jumps to reach the last index. You can assume that you can always reach the last index.

[46.](1-99/40-49/46.py)
**Permutations** - 
Given a collection of distinct integers, return all possible permutations.

[47.](1-99/40-49/47.py)
**Permutations II** - 
Given a collection of integers that might contain duplicates, return all possible unique permutations.

[48.](1-99/40-49/48.py)
**Rotate Image** - 
You are given an `n x n` 2D matrix representing an image. Rotate the matrix 90 degrees clockwise in-place.

[49.](1-99/40-49/49.py)
**Group Anagrams** - 
Given an array of strings, group anagrams together.

</details>

<details>
<summary><b>50-59</b></summary>

[50.](1-99/50-59/50.py)
**pow(x, n)** -
Implement `pow(x, n)`, which calculates `x` raised to the power `n` (<code>x<sup>n</sup></code>).

[51.](1-99/50-59/51.py)
**_n_-queens** - 
The _n_-queens puzzle is the problem of placing `n` queens on an `n × n` chessboard such that no two queens attack 
each other. Given an integer `n`, return all distinct solutions to the _n_-queens puzzle.

[52.](1-99/50-59/52.py)
**_n_-queens II** - 
The _n_-queens puzzle is the problem of placing `n` queens on an `n × n` chessboard such that no two queens attack 
each other. Given an integer `n`, return the number of distinct solutions to the _n_-queens puzzle.

[53.](1-99/50-59/53.py)
**Maximum Subarray** - 
Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest 
sum and return its sum.

[54.](1-99/50-59/54.py)
**Spiral Matrix** - 
Given a matrix of `m x n` elements (`m` rows, `n` columns), return all elements of the matrix in spiral order.

[55.](1-99/50-59/55.py)
**Jump Game** - 
You are given an array of non-negative integers, and are initially positioned at the first index of the array. 
Each element in the array represents your maximum jump length from that position. 
Determine if you are able to reach the last index.

[56.](1-99/50-59/56.py)
**Merge Intervals** - 
Given a collection of intervals, merge all overlapping intervals.

[57.](1-99/50-59/57.py)
**Insert Interval** - 
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.

[58.](1-99/50-59/58.py)
**Length of Last Word** - 
Given a string `s` consisting of upper/lower-case characters and empty space characters `' '`, return the length of 
the last word in the string. If the last word does not exist, return `0`.

[59.](1-99/50-59/59.py)
**Spiral Matrix II** - 
Given a positive integer `n`, generate a square matrix filled with elements from `1` to <code>n<sup>2</sup></code> 
in spiral order.

</details>

<details>
<summary><b>60-69</b></summary>

[60.](1-99/60-69/60.py)
**Permutation Sequence** -
Given `n` and `k`, return the k<sup>th</sup> permutation of the permutations obtained from the set `[1, 2, 3, ..., n]`.

[61.](1-99/60-69/61.py)
**Rotate List** - 
Given a linked list, rotate the list to the right by `k` places, where `k` is non-negative.

[62.](1-99/60-69/62.py)
**Unique Paths** - 
A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point 
in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there?

[63.](1-99/60-69/63.py)
**Unique Paths II** - 
A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point 
in time. The robot is trying to reach the bottom-right corner of the grid. Now consider if some obstacles are added to 
the grid. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively.

[64.](1-99/60-69/64.py)
**Minimum Path Sum** - 
Given an `m x n` grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the 
sum of all numbers along its path. You can only move either down or right at any point in time.

[65.](1-99/60-69/65.py)
**Valid Number** - 
Validate if a given string can be interpreted as a decimal number.

[66.](1-99/60-69/66.py)
**Plus One** - 
Given a non-empty array of digits representing a non-negative integer, add one to the integer. The digits are stored 
such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.

[67.](1-99/60-69/67.py)
**Add Binary** - 
Given two binary strings, return their sum (also a binary string). The input strings are both non-empty.

[68.](1-99/60-69/68.py)
**Text Justification** - 
Given an array `words` and a width `max_width`, format the text such that each line has exactly `max_width` characters 
and is fully justified. Extra spaces between words should be distributed as evenly as possible, with priority to the 
slots on the left. The last line of text should be left justified, with no extra space inserted between words.

[69.](1-99/60-69/69.py)
**sqrt(x)** - 
Compute and return the decimally truncated square root of `x`, where `x` is guaranteed to be a non-negative integer.

</details>

<details>
<summary><b>70-79</b></summary>

[70.](1-99/70-79/70.py)
**Climbing Stairs** -
You are climbing a staircase with `n` steps. Each time you can either climb 1 or 2 steps.
In how many distinct ways can you climb to the top?

[71.](1-99/70-79/71.py)
**Simplify Path** - 
Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

[72.](1-99/70-79/72.py)
**Edit Distance** - 
Given two words `word1` and `word2`, find the minimum number of operations required to convert `word1` to `word2`.

[73.](1-99/70-79/73.py)
**Set Matrix Zeroes** - 
Given an `m x n` matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

[74.](1-99/70-79/74.py)
**Search a 2D Matrix** - 
Write an efficient algorithm that searches for a value in an `m x n` matrix of integers. Each row is sorted from left 
to right. The first integer of each row is greater than the last integer of the previous row.

[75.](1-99/70-79/75.py)
**Sort Colors** - 
Given an array with `n` objects colored red, white or blue (represented by integers `0`, `1`, and `2`), sort them 
in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

[76.](1-99/70-79/76.py)
**Minimum Window Substring** - 
Given strings `S` and `T`, find the minimum window in `S` which contains all characters of `T` in complexity `O(n)`.

[77.](1-99/70-79/77.py)
**Combinations** - 
Given two integers `n` and `k`, return all possible combinations of `k` numbers out of `1 ... n`.

[78.](1-99/70-79/78.py)
**Subsets** - 
Given a set of distinct integers `nums`, return all possible subsets (the power set).

[79.](1-99/70-79/79.py)
**Word Search** - 
Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of 
sequentially adjacent cells, where "adjacent" cells are those horizontally or vertically neighboring. 
The same cell may not be used more than once.

</details>

<details>
<summary><b>80-89</b></summary>

[80.](1-99/80-89/80.py)
**Remove Duplicates from Sorted Array II** -
Given a sorted array `nums`, remove the duplicates in-place such that duplicates appear at most twice and return the
new length.

[81.](1-99/80-89/81.py)
**Search in Rotated Sorted Array II** - 
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(e.g., `[0, 0, 1, 2, 2, 5, 6]` might become `[2, 5, 6, 0, 0, 1, 2]`).
You are given a target value to search. If found in the array return `True`, otherwise return `False`.

[82.](1-99/80-89/82.py)
**Remove Duplicates from Sorted List II** - 
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the 
original list. Return the linked list sorted as well.

[83.](1-99/80-89/83.py)
**Remove Duplicates from Sorted List** - 
Given a sorted linked list, delete all duplicates such that each element appears only once.

[84.](1-99/80-89/84.py)
**Largest Rectangle in Histogram** - 
Given `n` non-negative integers representing the histogram's bar height where the width of each bar is 1, find the 
area of the largest rectangle in the histogram.

[85.](1-99/80-89/85.py)
**Maximal Rectangle** - 
Given a 2D matrix filled with `0`s and `1`s, find the largest rectangle containing only `1`s and return its area.

[86.](1-99/80-89/86.py)
**Partition List** - 
Given a linked list and a value `x`, partition it such that all nodes less than `x` come before nodes greater than or 
equal to `x`. You should preserve the original relative order of the nodes in each of the two partitions.

[87.](1-99/80-89/87.py)
**Scramble String** - 
Given a string `s1`, we may represent it as a binary tree by partitioning it into two non-empty substrings recursively.
To scramble the string, we may choose any non-leaf node and swap its two children, repeating this process. 
Given two strings `s1` and `s2` of the same length, determine if `s2` is a scrambled string of `s1`.

[88.](1-99/80-89/88.py)
**Merge Sorted Array** - 
Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array.

[89.](1-99/80-89/89.py)
**Gray Code** - 
The Gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative 
integer `n` representing the total number of bits in the code, print a Gray code sequence.

</details>

<details>
<summary><b>90-99</b></summary>

[90.](1-99/90-99/90.py)
**Subsets II** -
Given a collection of integers that might contain duplicates, `nums`, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.

[91.](1-99/90-99/91.py)
**Decode Ways** - 
A message containing letters A-Z is being encoded to numbers using the following mapping: `A->1, B->2, ..., Z->26`. 
Given a non-empty string containing only digits, determine the total number of ways to decode it.

[92.](1-99/90-99/92.py)
**Reverse Linked List II** - 
Reverse a linked list from position `m` to `n`. Do it in one pass.

[93.](1-99/90-99/93.py)
**Restore IP Addresses** - 
Given a string containing only digits, return all possible valid IP address combinations.

[94.](1-99/90-99/94.py)
**Binary Tree Inorder Traversal** - 
Given a binary tree, return the inorder traversal of its nodes' values.

[95.](1-99/90-99/95.py)
**Unique Binary Search Trees II** - 
Given an integer `n`, generate all structurally unique BST's (binary search trees) that store values `1 ... n`.

[96.](1-99/90-99/96.py)
**Unique Binary Search Trees** - 
Given an integer `n`, how many structurally unique BST's (binary search trees) can store values `1 ... n`?

[97.](1-99/90-99/97.py)
**Interleaving String** - 
Given strings `s1`, `s2`, `s3`, find whether `s3` can be formed by the interleaving of `s1` and `s2`.

[98.](1-99/90-99/98.py)
**Validate Binary Search Tree** - 
Given a binary tree, determine if it is a valid binary search tree (BST).

[99.](1-99/90-99/99.py)
**Recover Binary Search Tree** - 
Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.

</details>

<details>
<summary><b>100-109</b></summary>

[100.](100-199/100-109/100.py)
**Same Tree** -
Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

[101.](100-199/100-109/101.py)
**Symmetric Tree** -
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

[102.](100-199/100-109/102.py)
**Binary Tree Level Order Traversal** -
Given the root of a binary tree, return the level order traversal of its nodes' values. 
(i.e., from left to right, level by level).

[103.](100-199/100-109/103.py)
**Binary Tree Zigzag Level Order Traversal** -
Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. 
(i.e., from left to right, then right to left for the next level and alternate between).

[104.](100-199/100-109/104.py)
**Maximum Depth of Binary Tree** -
Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes 
along the longest path from the root node down to the farthest leaf node.

[105.](100-199/100-109/105.py)
**Construct Binary Tree from Preorder and Inorder Traversal** -
Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree 
and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.

[106.](100-199/100-109/106.py)
**Construct Binary Tree from Inorder and Postorder Traversal** -
Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree 
and `postorder` is the postorder traversal of the same tree, construct and return the binary tree.

[107.](100-199/100-109/107.py)
**Binary Tree Level Order Traversal II** -
Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. 
(i.e., from left to right, level by level from leaf to root).

[108.](100-199/100-109/108.py)
**Convert Sorted Array to Binary Search Tree** -
Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced 
binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every 
node never differs by more than one.

[109.](100-199/100-109/109.py)
**Convert Sorted List to Binary Search Tree** -
Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced 
binary search tree.

</details>

<details>
<summary><b>110-119</b></summary>

[110.](100-199/110-119/110.py)
**Balanced Binary Tree** -
Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree 
in which the left and right subtrees of every node differ in height by no more than 1.

[111.](100-199/110-119/111.py)
**Minimum Depth of Binary Tree** -
Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path 
from the root node down to the nearest leaf node.

[112.](100-199/110-119/112.py)
**Path Sum** -
Given the root of a binary tree and an integer `target_sum`, return `True` if the tree has a root-to-leaf path 
such that adding up all the values along the path equals `target_sum`. A leaf is a node with no children.

[113.](100-199/110-119/113.py)
**Path Sum II** -
Given the root of a binary tree and an integer `target_sum`, return all root-to-leaf paths where the sum of the 
node values in the path equals `target_sum`. Each path should be returned as a list of the node values.

[114.](100-199/110-119/114.py)
**Flatten Binary Tree to Linked List** -
Given the root of a binary tree, flatten the tree into a "linked list".

[115.](100-199/110-119/115.py)
**Distinct Subsequences** -
Given two strings `s` and `t`, return the number of distinct subsequences of `s` which equal `t`.

[116.](100-199/110-119/116.py)
**Populating Next Right Pointers in Each Node** -
You are given a perfect binary tree where all leaves are on the same level, and every parent has two children.
Make each node's `next` variable point to its next right node. If there is no next right node, the next pointer 
should be set to `None`.

[117.](100-199/110-119/117.py)
**Populating Next Right Pointers in Each Node II** -
Given a binary tree, populate each `next` variable to point to its next right node. If there is no next right node, 
the `next` variable should be set to `None`.

[118.](100-199/110-119/118.py)
**Pascal's Triangle** -
Given an integer `numRows`, return the first `numRows` rows of Pascal's triangle.

[119.](100-199/110-119/119.py)
**Pascal's Triangle II** -
Given an integer `rowIndex`, return the <code>rowIndex<sup>th</sup></code> (0-indexed) row of Pascal's triangle.

</details>

<details>
<summary><b>120-129</b></summary>

[120.](100-199/120-129/120.py)
**Triangle Path Sum** -
Given a `triangle` array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent 
number of the row below. More formally, if you are on index `i` on the current row, you may move to either `i` or 
`i + 1` on the next row.

[121.](100-199/120-129/121.py)
**Best Time to Buy and Sell Stock** -
You are given an array `prices` where `prices[i]` is the price of a given stock on the <code>i<sup>th</sup></code> day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future 
to sell that stock. Return the maximum profit you can achieve. If you cannot achieve any profit, return `0`.

[122.](100-199/120-129/122.py)
**Best Time to Buy and Sell Stock II** -
You are given an array `prices` where `prices[i]` is the price of a given stock on the <code>i<sup>th</sup></code> day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. 
However, you can sell it then immediately buy it on the same day. Find and return the maximum profit you can achieve.

[123.](100-199/120-129/123.py)
**Best Time to Buy and Sell Stock III** -
You are given an array `prices` where `prices[i]` is the price of a given stock on the <code>i<sup>th</sup></code> day.
Find the maximum profit you can achieve. You may complete at most two transactions. You may not engage in multiple
transactions simultaneously (i.e., you must sell the stock before you buy again).

[124.](100-199/120-129/124.py)
**Binary Tree Maximum Path Sum** -
A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge 
connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass 
through the root. Given the root of a binary tree, return the maximum path sum of any path.

[125.](100-199/120-129/125.py)
**Valid Palindrome** -
Given a string `s`, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

[126.](100-199/120-129/126.py)
**Word Ladder II** -
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return all the shortest transformation 
sequences from `beginWord` to `endWord`, or an empty list if no such sequence exists. Each sequence should be 
returned as a list of the words <code>[beginWord,  s<sub>1</sub>,  s<sub>2</sub>,  ...,  endWord]</code>.

[127.](100-199/120-129/127.py)
**Word Ladder** -
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest 
transformation sequence from `beginWord` to `endWord`, or 0 if no such sequence exists.

[128.](100-199/120-129/128.py)
**Longest Consecutive Sequence** -
Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.

[129.](100-199/120-129/129.py)
**Sum Root to Leaf Numbers** -
You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree 
represents a number. Return the total sum of all root-to-leaf numbers. 

</details>

<details>
<summary><b>130-139</b></summary>

[130.](100-199/130-139/130.py)
**Surrounded Regions** -
Given an `m x n` matrix board containing `'X'` and `'O'`, capture all regions that are 4-directionally surrounded 
by `'X'`. A region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.

[131.](100-199/130-139/131.py)
**Palindrome Partitioning** -
Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible 
palindrome partitionings of `s`.

[132.](100-199/130-139/132.py)
**Palindrome Partitioning II** -
Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return the minimum 
cuts needed for a palindrome partitioning of s.

[133.](100-199/130-139/133.py)
**Clone Graph** -
Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.
Each node in the graph contains a value (`int`) and a list (`list[Node]`) of its neighbours.

[134.](100-199/130-139/134.py)
**Gas Stations** -
There are `n` gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station 
is `gas[i]`. You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the 
<code>i<sup>th</sup></code> station to its next <code>i+1<sup>th</sup></code> station. You begin the journey with an 
empty tank at one of the gas stations. Given two integer arrays `gas` and `cost`, return the starting gas station's 
index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there exists a 
solution, it is guaranteed to be unique.

[135.](100-199/130-139/135.py)
**Candy** -
There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.
You are giving candies to these children subjected to the following requirements: Each child must have at least one 
candy, and children with a higher rating get more candies than their neighbors. Return the minimum number of candies 
you need to have to distribute the candies to the children.

[136.](100-199/130-139/136.py)
**Single Number** -
Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.

[137.](100-199/130-139/137.py)
**Single Number II** -
Given a non-empty integer array `nums`, every element appears three times except for one, which appears exactly once. 
Find the single element and return it. Your solution must have linear runtime complexity and constant extra space.

[138.](100-199/130-139/138.py)
**Copy List with Random Pointer** -
A linked list of length `n` is given such that each node contains an additional `random` pointer, which could point 
to any node in the list, or `None`. Construct a deep copy of the list and return the head.

[139.](100-199/130-139/139.py)
**Word Break** -
Given a string `s` and a list of strings `wordDict`, return `True` if `s` can be segmented into a space-separated 
sequence of one or more dictionary words.

</details>

<details>
<summary><b>140-149</b></summary>

[140.](100-199/140-149/140.py)
**Word Break II** -
Given a string `s` and a list of strings `wordDict`, add spaces in `s` to construct a sentence where each word is 
a valid dictionary word. Return all such possible sentences in any order.

[141.](100-199/140-149/141.py)
**Linked List Cycle** -
Given `head`, the head of a linked list, determine if the linked list has a cycle in it.  There is a cycle in a 
linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.

[142.](100-199/140-149/142.py)
**Linked List Cycle II** -
Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return `None`.

[143.](100-199/140-149/143.py)
**Reorder List** -
You are given the head of a singly linked-list. The list can be represented as: 
<code>L<sub>0</sub> → L<sub>1</sub> → ... → L<sub>n-1</sub> → L<sub>n</sub></code>.
Reorder the list to be in the following form:
<code>L<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n-1</sub> → L<sub>2</sub> → L<sub>n-2</sub> → ...</code>.

[144.](100-199/140-149/144.py)
**Binary Tree Preorder Traversal** -
Given the root of a binary tree, return the preorder traversal of its nodes' values.

[145.](100-199/140-149/145.py)
**Binary Tree Postorder Traversal** -
Given the root of a binary tree, return the postorder traversal of its nodes' values.

[146.](100-199/140-149/146.py)
**LRU Cache** -
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

[147.](100-199/140-149/147.py)
**Insertion Sort List** -
Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.

[148.](100-199/140-149/148.py)
**Sort List** -
Given the head of a linked list, return the head of the list after sorting it in ascending order.

[149.](100-199/140-149/149.py)
**Max Points on a Line** -
Given an array `points` where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the X-Y 
plane, return the maximum number of points that lie on the same straight line.

</details>
