# LeetCode

My solutions to LeetCode problems.

Each file has a problem statement, my solution, and a couple of tests, occasionally with my reasoning on how the 
solution was achieved.

[1.](10/1.py)
**Two Sum** - 
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

[2.](10/2.py)
**Add Two Numbers** - 
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse 
order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

[3.](10/3.py)
**Longest Substring Without Repeating Characters** - 
Given a string, find the length of the longest substring without repeating characters.

[4.](10/4.py)
**Median of Two Sorted Arrays** - 
There are two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively.
Find the median of the two sorted arrays.

[5.](10/5.py)
**Longest Palindromic Substring** - 
Given a string `s`, find the longest palindromic substring in `s`. 
You may assume that the maximum length of `s` is 1000.

[6.](10/6.py)
**ZigZag Conversion** - 
The string `PAYPALISHIRING` is written in a zigzag pattern on a given number of rows like this:

    P   A   H   N
    A P L S I I G
    Y   I   R

And then read line by line: `PAHNAPLSIIGYIR`

Write the code that will take a string and make this conversion given the number of rows.

[7.](10/7.py)
**Reverse Integer** - 
Given a 32-bit signed integer, reverse digits of an integer.

[8.](10/8.py)
**String to Integer** - 
Implement `atoi` which converts a string to an integer. The function first discards as many whitespace characters as 
necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional 
initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.
The string can contain additional characters after those that form the integral number, which are ignored and have 
no effect on the behavior of this function.

[9.](10/9.py)
**Palindrome Number** - 
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

[10.](10/10.py)
**Regular Expression Matching** - 
Given an input string `s` and a pattern `p`, implement regular expression matching with support for `.` and `*`.

[11.](20/11.py)
**Container With Most Water** - 
You are given `n` non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, where each 
represents a point at coordinate <code>(i, a<sub>i</sub>)</code>. `n` vertical lines are drawn such that the two 
endpoints of line `i` are at <code>(i, a<sub>i</sub>)</code> and `(i, 0)`. Find two lines, which together with 
the x-axis form a container, such that the container contains the most water.

[12.](20/12.py)
**Integer to Roman** - 
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from `1` to `3999`.

[13.](20/13.py)
**Roman to Integer** - 
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from `1` to `3999`.

[14.](20/14.py)
**Longest Common Prefix** - 
Write a function to find the longest common prefix string amongst an array of strings.

[15.](20/15.py)
**3Sum** - 
Given an array `nums` of `n` integers, find all unique triplets in the array which give the sum of zero.

[16.](20/16.py)
**3Sum Closest** - 
Given an array `nums` of `n` integers and an integer target, find three integers in nums such that the sum is closest 
to `target`. Return the sum of the three integers. You may assume that each input has exactly one solution.

[17.](20/17.py)
**Letter Combinations of a Phone Number** - 
Given a string containing digits from `2-9` inclusive, return all possible letter combinations (those on telephone
buttons) that the number could represent.

[18.](20/18.py)
**4Sum** - 
Given an array `nums` of `n` integers and an integer `target`, are there elements `a`, `b`, `c`, and `d` in `nums` 
such that `a + b + c + d = target`? Find all unique quadruplets in the array which gives the sum of `target`.

[19.](20/19.py)
**Remove Nth Node From End of List** - 
Given a linked list, remove the `n`<sup>th</sup> node from the end of list and return its head.

[20.](20/20.py)
**Valid Parentheses** - 
Given a string containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid.

[21.](30/21.py)
**Merge Two Sorted Lists** - 
Merge two sorted linked lists and return it as a new list. 
The new list should be made by splicing together the nodes of the first two lists.

[22.](30/22.py)
**Generate Parentheses** - 
Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

[23.](30/23.py)
**Merge k Sorted Lists** - 
Merge `k` sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

[24.](30/24.py)
**Swap Nodes in Pairs** - 
Given a linked list, swap every two adjacent nodes and return its head.

[25.](30/25.py)
**Reverse Nodes in k-Group** - 
Given a linked list, reverse the nodes of a linked list `k` at a time and return its modified list.

[26.](30/26.py)
**Remove Duplicates from Sorted Array** - 
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and return the 
new length.

[27.](30/27.py)
**Remove Element** - 
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.

[28.](30/28.py)
**Find Needle in Haystack** - 
Return the index of the first occurrence of a substring `needle` in a string `haystack`, 
or -1 if `needle` is not part of `haystack`.

[29.](30/29.py)
**Divide Two Integers** - 
Given two integers `dividend` and `divisor`, divide two integers without using multiplication, 
division or mod operators. Return the quotient after dividing `dividend` by `divisor`.

[30.](30/30.py)
**Substring with Concatenation of All Words** - 
You are given a string `s`, and a list of words `words` that are all of the same length. 
Find all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once and 
without any intervening characters.

[31.](40/31.py)
**Next Permutation** - 
Implement `next_permutation`, which rearranges numbers into the lexicographically next greater permutation. If such an 
arrangement is not possible, it must be rearranged as the lowest possible order (i.e. sorted in ascending order). 
The replacement must be in-place and use only constant extra memory.

[32.](40/32.py)
**Longest Valid Parentheses** - 
Given a string containing just the characters `(` and `)`, find the length of the longest valid parentheses substring.

[33.](40/33.py)
**Search in Rotated Sorted Array** - 
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand, e.g. 
`[0, 1, 2, 4, 5, 6, 7]` might become `[4, 5, 6, 7, 0, 1, 2]`. You are given a target value to search. 
If found in the array return its index, otherwise return `-1`. You may assume no duplicate exists in the array. 
Your algorithm's runtime complexity must be in the order of `O(log n)`.

[34.](40/34.py)
**Find First and Last Position of Element in Sorted Array** - 
Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given target 
value. Your algorithm's runtime complexity must be in the order of `O(log n)`.

[35.](40/35.py)
**Search Insert Position** - 
Given a sorted array and a target value, return the index if the target is found. If not, 
return the index where it would be if it were inserted in order. You may assume no duplicates in the array.

[36.](40/36.py)
**Valid Sudoku** - 
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated.

[37.](40/37.py)
**Sudoku Solver** - 
Write a program to solve a Sudoku puzzle by filling the empty cells.

[38.](40/38.py)
**Count and Say** - 
The count-and-say sequence is the sequence of integers with the first five terms as following: 
`1, 11, 21, 1211, 111221`. `1` is read off as "one 1" or `11`. `11` is read off as "two 1s" or `21`. 
`21` is read off as "one 2, then one 1" or `1211`. Given an integer `n` where `1 ≤ n ≤ 30`, 
generate the *n*th term of the count-and-say sequence.

[39.](40/39.py)
**Combination Sum** - 
Given a set of candidate numbers `candidates` (without duplicates) and a target number `target`, 
find all unique combinations in `candidates` where the candidate numbers sum to `target`.
The same repeated number may be chosen from `candidates` unlimited number of times.

[40.](40/40.py)
**Combination Sum II** - 
Given a collection of candidate numbers `candidates` and a target number `target`, 
find all unique combinations in `candidates` where the candidate numbers sum to `target`.
Each number in `candidates` may only be used once in the combination.

[40.](40/40.py)
**First Missing Positive** - 
Given an unsorted integer array, find the smallest missing positive integer. 
Your algorithm should run in `O(n)` time and use constant extra space.

[42.](50/42.py)
**Trapping Rain Water** - 
Given `n` non-negative integers representing an elevation map where the width of each bar is 1, 
compute how much water it is able to trap after raining.

[43.](50/43.py)
**Multiply Strings** - 
Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, 
also represented as a string. You must not convert the inputs to integers directly.

[44.](50/44.py)
**Wildcard Matching** - 
Given an input string `s` and a pattern `p`, implement wildcard pattern matching with support for `?` and `*`.
`?` Matches any single character, while `*` matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string.

[45.](50/45.py)
**Jump Game II** - 
You are given an array of non-negative integers, and are initially positioned at the first index of the array. 
Each element in the array represents your maximum jump length from that position. 
Return the fewest number of jumps to reach the last index. You can assume that you can always reach the last index.

[46.](50/46.py)
**Permutations** - 
Given a collection of distinct integers, return all possible permutations.

[47.](50/47.py)
**Permutations II** - 
Given a collection of integers that might contain duplicates, return all possible unique permutations.

[48.](50/48.py)
**Rotate Image** - 
You are given an `n x n` 2D matrix representing an image. Rotate the matrix 90 degrees clockwise in-place.

[49.](50/49.py)
**Group Anagrams** - 
Given an array of strings, group anagrams together.

[50.](50/50.py)
**pow(x, n)** - 
Implement `pow(x, n)`, which calculates `x` raised to the power `n` (<code>x<sup>n</sup></code>).

[51.](60/51.py)
**_n_-queens** - 
The _n_-queens puzzle is the problem of placing `n` queens on an `n × n` chessboard such that no two queens attack 
each other. Given an integer `n`, return all distinct solutions to the _n_-queens puzzle.

[52.](60/52.py)
**_n_-queens II** - 
The _n_-queens puzzle is the problem of placing `n` queens on an `n × n` chessboard such that no two queens attack 
each other. Given an integer `n`, return the number of distinct solutions to the _n_-queens puzzle.

[53.](60/53.py)
**Maximum Subarray** - 
Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest 
sum and return its sum.

[54.](60/54.py)
**Spiral Matrix** - 
Given a matrix of `m x n` elements (`m` rows, `n` columns), return all elements of the matrix in spiral order.

[55.](60/55.py)
**Jump Game** - 
You are given an array of non-negative integers, and are initially positioned at the first index of the array. 
Each element in the array represents your maximum jump length from that position. 
Determine if you are able to reach the last index.

[56.](60/56.py)
**Merge Intervals** - 
Given a collection of intervals, merge all overlapping intervals.

[57.](60/57.py)
**Insert Interval** - 
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.

[58.](60/58.py)
**Length of Last Word** - 
Given a string `s` consisting of upper/lower-case characters and empty space characters `' '`, return the length of 
the last word in the string. If the last word does not exist, return `0`.

[59.](60/59.py)
**Spiral Matrix II** - 
Given a positive integer `n`, generate a square matrix filled with elements from `1` to <code>n<sup>2</sup></code> 
in spiral order.

[60.](60/60.py)
**Permutation Sequence** - 
Given `n` and `k`, return the k<sup>th</sup> permutation of the permutations obtained from the set `[1,2,3,...,n]`.

[61.](70/61.py)
**Rotate List** - 
Given a linked list, rotate the list to the right by `k` places, where `k` is non-negative.

[62.](70/62.py)
**Unique Paths** - 
A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point 
in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there?

[63.](70/63.py)
**Unique Paths II** - 
A robot is located at the top-left corner of an `m x n` grid. The robot can only move either down or right at any point 
in time. The robot is trying to reach the bottom-right corner of the grid. Now consider if some obstacles are added to 
the grid. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively.

[64.](70/64.py)
**Minimum Path Sum** - 
Given an `m x n` grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the 
sum of all numbers along its path. You can only move either down or right at any point in time.
